<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PluginProxyController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">arcana-cloud-java</a> &gt; <a href="index.source.html" class="el_package">com.arcana.cloud.controller</a> &gt; <span class="el_source">PluginProxyController.java</span></div><h1>PluginProxyController.java</h1><pre class="source lang-java linenums">package com.arcana.cloud.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnExpression;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.util.Enumeration;

/**
 * Proxy controller for plugin REST endpoints in layered/K8s HTTP mode.
 *
 * &lt;p&gt;When running in layered mode with HTTP protocol, plugins are hosted
 * on the Service Layer. This controller proxies plugin requests from the
 * Controller Layer to the Service Layer.&lt;/p&gt;
 *
 * &lt;p&gt;URL pattern: /api/v1/plugins/{pluginKey}/** â†’ Service Layer&lt;/p&gt;
 */
@RestController
@RequestMapping(&quot;/api/v1/proxy/plugins&quot;)
@Tag(name = &quot;Plugin Proxy&quot;, description = &quot;Proxy for plugin endpoints in layered mode&quot;)
@ConditionalOnProperty(name = &quot;communication.protocol&quot;, havingValue = &quot;http&quot;)
@ConditionalOnExpression(&quot;'${deployment.layer:}' == 'controller'&quot;)
public class PluginProxyController {

<span class="fc" id="L35">    private static final Logger log = LoggerFactory.getLogger(PluginProxyController.class);</span>

    private final RestTemplate restTemplate;

    @Value(&quot;${service.http.url:http://localhost:8081}&quot;)
    private String serviceLayerUrl;

<span class="fc" id="L42">    public PluginProxyController(RestTemplate restTemplate) {</span>
<span class="fc" id="L43">        this.restTemplate = restTemplate;</span>
<span class="fc" id="L44">    }</span>

    /**
     * Proxies GET requests to plugin endpoints.
     */
    @GetMapping(&quot;/{pluginKey}/**&quot;)
    @Operation(summary = &quot;Proxy GET request to plugin&quot;)
    public ResponseEntity&lt;String&gt; proxyGet(
            @PathVariable String pluginKey,
            HttpServletRequest request) {
<span class="fc" id="L54">        return proxyRequest(pluginKey, request, HttpMethod.GET, null);</span>
    }

    /**
     * Proxies POST requests to plugin endpoints.
     */
    @PostMapping(&quot;/{pluginKey}/**&quot;)
    @Operation(summary = &quot;Proxy POST request to plugin&quot;)
    public ResponseEntity&lt;String&gt; proxyPost(
            @PathVariable String pluginKey,
            @RequestBody(required = false) String body,
            HttpServletRequest request) {
<span class="fc" id="L66">        return proxyRequest(pluginKey, request, HttpMethod.POST, body);</span>
    }

    /**
     * Proxies PUT requests to plugin endpoints.
     */
    @PutMapping(&quot;/{pluginKey}/**&quot;)
    @Operation(summary = &quot;Proxy PUT request to plugin&quot;)
    public ResponseEntity&lt;String&gt; proxyPut(
            @PathVariable String pluginKey,
            @RequestBody(required = false) String body,
            HttpServletRequest request) {
<span class="fc" id="L78">        return proxyRequest(pluginKey, request, HttpMethod.PUT, body);</span>
    }

    /**
     * Proxies PATCH requests to plugin endpoints.
     */
    @PatchMapping(&quot;/{pluginKey}/**&quot;)
    @Operation(summary = &quot;Proxy PATCH request to plugin&quot;)
    public ResponseEntity&lt;String&gt; proxyPatch(
            @PathVariable String pluginKey,
            @RequestBody(required = false) String body,
            HttpServletRequest request) {
<span class="fc" id="L90">        return proxyRequest(pluginKey, request, HttpMethod.PATCH, body);</span>
    }

    /**
     * Proxies DELETE requests to plugin endpoints.
     */
    @DeleteMapping(&quot;/{pluginKey}/**&quot;)
    @Operation(summary = &quot;Proxy DELETE request to plugin&quot;)
    public ResponseEntity&lt;String&gt; proxyDelete(
            @PathVariable String pluginKey,
            HttpServletRequest request) {
<span class="fc" id="L101">        return proxyRequest(pluginKey, request, HttpMethod.DELETE, null);</span>
    }

    /**
     * Proxies the request to the service layer.
     */
    private ResponseEntity&lt;String&gt; proxyRequest(
            String pluginKey,
            HttpServletRequest request,
            HttpMethod method,
            String body) {

        // Build the target URL
<span class="fc" id="L114">        String requestUri = request.getRequestURI();</span>
<span class="fc" id="L115">        String pluginPath = extractPluginPath(requestUri, pluginKey);</span>
<span class="fc" id="L116">        String queryString = request.getQueryString();</span>

<span class="fc" id="L118">        String targetUrl = buildTargetUrl(pluginKey, pluginPath, queryString);</span>

<span class="fc" id="L120">        log.debug(&quot;Proxying {} {} to {}&quot;, method, requestUri, targetUrl);</span>

        try {
            // Copy headers
<span class="fc" id="L124">            HttpHeaders headers = copyHeaders(request);</span>

            // Create request entity
<span class="fc" id="L127">            HttpEntity&lt;String&gt; requestEntity = new HttpEntity&lt;&gt;(body, headers);</span>

            // Execute request
<span class="fc" id="L130">            ResponseEntity&lt;String&gt; response = restTemplate.exchange(</span>
                targetUrl,
                method,
                requestEntity,
                String.class
            );

            // Return response with original status and headers
<span class="fc" id="L138">            return ResponseEntity</span>
<span class="fc" id="L139">                .status(response.getStatusCode())</span>
<span class="fc" id="L140">                .headers(filterResponseHeaders(response.getHeaders()))</span>
<span class="fc" id="L141">                .body(response.getBody());</span>

<span class="fc" id="L143">        } catch (RestClientException e) {</span>
<span class="fc" id="L144">            log.error(&quot;Failed to proxy request to plugin {}: {}&quot;, pluginKey, e.getMessage());</span>
<span class="fc" id="L145">            return ResponseEntity</span>
<span class="fc" id="L146">                .status(HttpStatus.BAD_GATEWAY)</span>
<span class="fc" id="L147">                .contentType(MediaType.APPLICATION_JSON)</span>
<span class="fc" id="L148">                .body(&quot;{\&quot;success\&quot;:false,\&quot;error\&quot;:\&quot;Failed to reach plugin service: &quot; +</span>
<span class="fc" id="L149">                      e.getMessage().replace(&quot;\&quot;&quot;, &quot;'&quot;) + &quot;\&quot;}&quot;);</span>
        }
    }

    /**
     * Extracts the plugin-specific path from the request URI.
     */
    private String extractPluginPath(String requestUri, String pluginKey) {
        // Remove /api/v1/proxy/plugins/{pluginKey} prefix
<span class="fc" id="L158">        String prefix = &quot;/api/v1/proxy/plugins/&quot; + pluginKey;</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        if (requestUri.startsWith(prefix)) {</span>
<span class="fc" id="L160">            String path = requestUri.substring(prefix.length());</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">            return path.isEmpty() ? &quot;&quot; : path;</span>
        }
<span class="nc" id="L163">        return &quot;&quot;;</span>
    }

    /**
     * Builds the target URL for the service layer.
     */
    private String buildTargetUrl(String pluginKey, String pluginPath, String queryString) {
<span class="fc" id="L170">        StringBuilder url = new StringBuilder(serviceLayerUrl);</span>

        // Remove trailing slash from base URL
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        if (url.charAt(url.length() - 1) == '/') {</span>
<span class="nc" id="L174">            url.setLength(url.length() - 1);</span>
        }

        // Standard plugin endpoint pattern on service layer
<span class="fc" id="L178">        url.append(&quot;/api/v1/plugins/&quot;).append(pluginKey);</span>

        // Add plugin-specific path
<span class="pc bpc" id="L181" title="1 of 4 branches missed.">        if (pluginPath != null &amp;&amp; !pluginPath.isEmpty()) {</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">            if (!pluginPath.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L183">                url.append(&quot;/&quot;);</span>
            }
<span class="fc" id="L185">            url.append(pluginPath);</span>
        }

        // Add query string
<span class="pc bpc" id="L189" title="1 of 4 branches missed.">        if (queryString != null &amp;&amp; !queryString.isEmpty()) {</span>
<span class="fc" id="L190">            url.append(&quot;?&quot;).append(queryString);</span>
        }

<span class="fc" id="L193">        return url.toString();</span>
    }

    /**
     * Copies relevant headers from the incoming request.
     */
    private HttpHeaders copyHeaders(HttpServletRequest request) {
<span class="fc" id="L200">        HttpHeaders headers = new HttpHeaders();</span>

<span class="fc" id="L202">        Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        while (headerNames.hasMoreElements()) {</span>
<span class="fc" id="L204">            String headerName = headerNames.nextElement();</span>

            // Skip hop-by-hop headers
<span class="fc bfc" id="L207" title="All 2 branches covered.">            if (isHopByHopHeader(headerName)) {</span>
<span class="fc" id="L208">                continue;</span>
            }

<span class="fc" id="L211">            Enumeration&lt;String&gt; headerValues = request.getHeaders(headerName);</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">            while (headerValues.hasMoreElements()) {</span>
<span class="fc" id="L213">                headers.add(headerName, headerValues.nextElement());</span>
            }
<span class="fc" id="L215">        }</span>

        // Add forwarding headers
<span class="fc" id="L218">        headers.set(&quot;X-Forwarded-For&quot;, request.getRemoteAddr());</span>
<span class="fc" id="L219">        headers.set(&quot;X-Forwarded-Proto&quot;, request.getScheme());</span>
<span class="fc" id="L220">        headers.set(&quot;X-Forwarded-Host&quot;, request.getServerName());</span>

<span class="fc" id="L222">        return headers;</span>
    }

    /**
     * Filters response headers to remove hop-by-hop headers.
     */
    private HttpHeaders filterResponseHeaders(HttpHeaders headers) {
<span class="fc" id="L229">        HttpHeaders filtered = new HttpHeaders();</span>
<span class="fc" id="L230">        headers.forEach((name, values) -&gt; {</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">            if (!isHopByHopHeader(name)) {</span>
<span class="fc" id="L232">                filtered.addAll(name, values);</span>
            }
<span class="fc" id="L234">        });</span>
<span class="fc" id="L235">        return filtered;</span>
    }

    /**
     * Checks if a header is a hop-by-hop header that should not be forwarded.
     */
    private boolean isHopByHopHeader(String headerName) {
<span class="fc" id="L242">        String lower = headerName.toLowerCase();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">        return lower.equals(&quot;connection&quot;) ||</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">               lower.equals(&quot;keep-alive&quot;) ||</span>
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">               lower.equals(&quot;proxy-authenticate&quot;) ||</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">               lower.equals(&quot;proxy-authorization&quot;) ||</span>
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">               lower.equals(&quot;te&quot;) ||</span>
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">               lower.equals(&quot;trailers&quot;) ||</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">               lower.equals(&quot;transfer-encoding&quot;) ||</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">               lower.equals(&quot;upgrade&quot;) ||</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">               lower.equals(&quot;host&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>